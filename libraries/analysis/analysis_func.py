# analysis_func.py
"""
A library of functions to perform analysis on enriched Spotify saved tracks data,
including track info, artist genres/popularity, and audio features.

Assumes input DataFrames contain columns generated by the multi-stage
data retrieval script (e.g., popularity, artist_popularity, artist_genres,
added_at, album_release_date, danceability, energy, valence, etc.).
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import List, Dict, Optional, Any, Union

# Optional: Import advanced libraries if implementing specific functions
# from scipy import stats
# from sklearn.preprocessing import StandardScaler
# from sklearn.cluster import KMeans
# import networkx as nx


# Optional: Configure plotting style globally
# sns.set_theme(style="whitegrid")
# plt.rcParams['figure.figsize'] = (12, 6) # Example default figure size

# --- Helper Functions ---

def _explode_genres(df: pd.DataFrame) -> pd.DataFrame:
    """Helper to explode the 'artist_genres' column into individual rows per genre."""
    if 'artist_genres' not in df.columns:
        raise ValueError("DataFrame must contain 'artist_genres' column.")

    # Ensure NaN values are handled before splitting
    temp_df = df.dropna(subset=['artist_genres']).copy()
    if temp_df.empty:
        # Return DataFrame with same columns as input + 'genre' if empty after dropna
        return pd.DataFrame(columns=df.columns.tolist() + ['genre'])

    temp_df['genre_list'] = temp_df['artist_genres'].str.split(',')
    genre_exploded_df = temp_df.explode('genre_list')
    # Handle potential empty strings after split if genres were like "pop,"
    genre_exploded_df['genre'] = genre_exploded_df['genre_list'].str.strip()
    genre_exploded_df = genre_exploded_df[genre_exploded_df['genre'].str.len() > 0]
    return genre_exploded_df.drop(columns=['genre_list'])

def _parse_release_date(df: pd.DataFrame, date_col: str = 'album_release_date') -> pd.DataFrame:
    """Helper to safely parse release date column into datetime objects and year."""
    if date_col not in df.columns:
         raise ValueError(f"DataFrame must contain '{date_col}' column.")

    df_copy = df.copy()
    # Handle YYYY, YYYY-MM, YYYY-MM-DD formats robustly
    df_copy['release_datetime'] = pd.to_datetime(df_copy[date_col], errors='coerce')
    # Extract year only after successful parsing
    df_copy['release_year'] = df_copy['release_datetime'].dt.year
    return df_copy

def _get_top_genres(df: pd.DataFrame, n: int = 10) -> List[str]:
    """Helper function to get the most frequent genres from an already exploded DataFrame or one with 'artist_genres'."""
    if 'genre' not in df.columns and 'artist_genres' not in df.columns:
         raise ValueError("DataFrame needs 'genre' or 'artist_genres' column.")

    if 'genre' not in df.columns:
        exploded_df = _explode_genres(df)
    else:
        exploded_df = df # Assume already exploded if 'genre' exists

    if exploded_df.empty:
        return []
    top_genres = exploded_df['genre'].value_counts().nlargest(n).index.tolist()
    return top_genres

# --- Time-Based Analysis ---

def plot_tracks_added_distribution(df: pd.DataFrame, period: str = 'M') -> Optional[plt.Axes]:
    """
    Plots the distribution of tracks added to the library over time.

    Args:
        df: DataFrame containing 'added_at' column (datetime).
        period: Pandas offset string ('M' for month, 'Y' for year, 'D' for day).

    Returns:
        Matplotlib Axes object with the plot, or None if data is empty.
    """
    if 'added_at' not in df.columns: raise ValueError("Missing 'added_at'.")
    if df.empty or df['added_at'].isnull().all(): return None
    
    counts = df.set_index('added_at').resample(period).size()
    ax = counts.plot(kind='line', figsize=(12, 6), title=f"Tracks Added Per {period}")
    ax.set_xlabel("Time")
    ax.set_ylabel("Number of Tracks Added")
    return ax

def plot_release_year_distribution(df: pd.DataFrame, bin_size: Optional[int] = 1) -> Optional[plt.Axes]:
    """
    Plots the distribution of album release years for saved tracks.

    Args:
        df: DataFrame containing 'album_release_date'.
        bin_size: Size of bins for histogram (e.g., 1 for year, 10 for decade). If None, use auto bins.

    Returns:
        Matplotlib Axes object with the histogram, or None if no valid years found.
    """
    df_parsed = _parse_release_date(df)
    years = df_parsed['release_year'].dropna()
    if years.empty: return None

    plt.figure(figsize=(12, 6))
    ax = sns.histplot(years, binwidth=bin_size, kde=False)
    ax.set_title("Distribution of Release Years")
    ax.set_xlabel("Year")
    ax.set_ylabel("Number of Tracks")
    return ax

def calculate_add_vs_release_lag(df: pd.DataFrame, time_unit: str = 'days') -> Optional[pd.Series]:
    """
    Calculates the time difference between track add and album release.

    Args:
        df: DataFrame with 'added_at' and 'album_release_date'.
        time_unit: 'days' or 'years'.

    Returns:
        Pandas Series containing the lag, or None if data is missing.
    """
    if 'added_at' not in df.columns: raise ValueError("Missing 'added_at'.")
    df_parsed = _parse_release_date(df)
    # Ensure both columns are datetime before subtraction
    if pd.api.types.is_datetime64_any_dtype(df_parsed['added_at']) and \
       pd.api.types.is_datetime64_any_dtype(df_parsed['release_datetime']):
        lag = (df_parsed['added_at'] - df_parsed['release_datetime'])
        if time_unit == 'years':
            return lag.dt.days / 365.25
        else: # Default to days
            return lag.dt.days
    else:
        return None


def plot_add_vs_release_lag_distribution(df: pd.DataFrame, time_unit: str = 'days', bins: int = 50) -> Optional[plt.Axes]:
    """Calculates and plots the distribution of the add vs. release lag."""
    lag_series = calculate_add_vs_release_lag(df, time_unit=time_unit)
    if lag_series is None or lag_series.isnull().all(): return None
    
    plt.figure(figsize=(12, 6))
    ax = sns.histplot(lag_series.dropna(), bins=bins)
    ax.set_title(f"Distribution of Lag Between Track Add and Release ({time_unit.capitalize()})")
    ax.set_xlabel(f"Lag ({time_unit.capitalize()})")
    ax.set_ylabel("Number of Tracks")
    return ax

def plot_feature_over_release_years(df: pd.DataFrame, feature: str, agg_func: str = 'mean', window: Optional[int] = 5) -> Optional[plt.Axes]:
    """
    Plots the trend of a numeric feature (e.g., popularity, energy) across release years.

    Args:
        df: DataFrame with 'album_release_date' and the specified feature.
        feature: The numeric column name to plot.
        agg_func: Aggregation function ('mean', 'median').
        window: Size of rolling average window (e.g., 5 for 5-year average). If None, plot raw aggregate.

    Returns:
        Matplotlib Axes object, or None if data is missing.
    """
    if feature not in df.columns: raise ValueError(f"Missing '{feature}'.")
    df_parsed = _parse_release_date(df)
    if df_parsed['release_year'].isnull().all(): return None

    agg_data = df_parsed.groupby('release_year')[feature].agg(agg_func).dropna()
    if agg_data.empty: return None

    plt.figure(figsize=(12, 6))
    if window:
        rolling_agg = agg_data.rolling(window=window, center=True, min_periods=1).mean()
        ax = rolling_agg.plot(label=f'{window}-Year Rolling {agg_func.capitalize()}')
        ax.set_ylabel(f'{window}-Year Rolling {agg_func.capitalize()} of {feature}')
    else:
        ax = agg_data.plot(label=f'{agg_func.capitalize()}')
        ax.set_ylabel(f'{agg_func.capitalize()} of {feature}')
        
    ax.set_title(f"Trend of {feature.replace('_', ' ').title()} Over Release Years")
    ax.set_xlabel("Release Year")
    ax.legend()
    return ax

# --- Popularity Analysis ---

def plot_popularity_distribution(df: pd.DataFrame, column: str = 'popularity') -> Optional[plt.Axes]:
    """Plots a histogram of popularity scores (track 'popularity' or 'artist_popularity')."""
    if column not in df.columns: raise ValueError(f"Missing '{column}'.")
    if df[column].isnull().all(): return None
    
    plt.figure(figsize=(10, 6))
    ax = sns.histplot(df[column].dropna(), kde=True)
    ax.set_title(f"Distribution of {column.replace('_', ' ').title()}")
    ax.set_xlabel(column.replace('_', ' ').title())
    return ax

def plot_popularity_correlation(df: pd.DataFrame) -> Optional[plt.Axes]:
    """Creates a scatter plot comparing track popularity vs. artist popularity."""
    if not all(c in df.columns for c in ['popularity', 'artist_popularity']):
        raise ValueError("Missing 'popularity' or 'artist_popularity'.")
    plot_df = df[['popularity', 'artist_popularity']].dropna()
    if plot_df.empty: return None

    plt.figure(figsize=(8, 8))
    ax = sns.scatterplot(data=plot_df, x='artist_popularity', y='popularity', alpha=0.5)
    ax.set_title("Track Popularity vs. Average Artist Popularity")
    ax.set_xlabel("Average Artist Popularity")
    ax.set_ylabel("Track Popularity")
    # Optional: Add correlation coefficient
    # corr = plot_df['artist_popularity'].corr(plot_df['popularity'])
    # ax.text(0.05, 0.95, f'Corr: {corr:.2f}', transform=ax.transAxes, ...)
    return ax

def get_top_n_items(df: pd.DataFrame, column: str, n: int = 20, ascending: bool = False) -> pd.DataFrame:
    """Gets the top N rows based on a specified numeric column."""
    if column not in df.columns: raise ValueError(f"Missing '{column}'.")
    return df.sort_values(by=column, ascending=ascending, na_position='last').head(n)

# --- Artist & Album Analysis ---

def get_top_n_artists(df: pd.DataFrame, n: int = 25) -> Optional[pd.DataFrame]:
    """Counts track occurrences per artist and returns the top N."""
    if 'artist_ids' not in df.columns: raise ValueError("Missing 'artist_ids'.")
    if df['artist_ids'].isnull().all(): return None

    # Assumes artist_ids is comma-separated string
    artists = df['artist_ids'].dropna().str.split(',').explode()
    artists = artists.str.strip()
    counts = artists.value_counts().nlargest(n)
    
    # Optional: map IDs back to names if 'artist_names' available and mapping is feasible
    return counts.reset_index().rename(columns={'index': 'artist_id', 'artist_ids': 'track_count'})


def get_top_n_albums(df: pd.DataFrame, n: int = 25) -> Optional[pd.DataFrame]:
    """Counts track occurrences per album and returns the top N."""
    if 'album_id' not in df.columns: raise ValueError("Missing 'album_id'.")
    if 'album_name' not in df.columns: raise ValueError("Missing 'album_name'.")
    if df['album_id'].isnull().all(): return None

    counts = df.groupby(['album_id', 'album_name']).size().nlargest(n)
    return counts.reset_index(name='track_count')

# --- Genre Analysis ---

def plot_genre_distribution(df: pd.DataFrame, top_n: int = 20) -> Optional[plt.Axes]:
    """Plots the distribution (bar chart) of the top N genres."""
    exploded_df = _explode_genres(df)
    if exploded_df.empty: return None

    counts = exploded_df['genre'].value_counts().nlargest(top_n)
    
    plt.figure(figsize=(12, 8))
    ax = sns.barplot(x=counts.values, y=counts.index, palette="viridis")
    ax.set_title(f"Top {top_n} Genres Distribution")
    ax.set_xlabel("Number of Tracks")
    ax.set_ylabel("Genre")
    return ax

def plot_feature_by_genre(df: pd.DataFrame, feature: str, top_n_genres: int = 10, plot_type: str = 'box') -> Optional[plt.Axes]:
    """Plots the distribution of a numeric feature across top N genres."""
    if feature not in df.columns: raise ValueError(f"Missing feature '{feature}'.")
    
    exploded_df = _explode_genres(df)
    if exploded_df.empty: return None
    
    top_genres = _get_top_genres(exploded_df, n=top_n_genres)
    plot_df = exploded_df[exploded_df['genre'].isin(top_genres)].copy()
    # Ensure feature is numeric
    plot_df[feature] = pd.to_numeric(plot_df[feature], errors='coerce')
    plot_df.dropna(subset=[feature], inplace=True)
    
    if plot_df.empty: return None

    plt.figure(figsize=(12, max(6, top_n_genres * 0.5))) # Adjust height
    order = top_genres # Plot in order of frequency
    
    if plot_type == 'box':
        ax = sns.boxplot(data=plot_df, y='genre', x=feature, order=order, palette="viridis")
    elif plot_type == 'violin':
        ax = sns.violinplot(data=plot_df, y='genre', x=feature, order=order, palette="viridis", inner='quartile')
    else:
        raise ValueError("plot_type must be 'box' or 'violin'")
        
    ax.set_title(f"Distribution of {feature.replace('_',' ').title()} by Top {top_n_genres} Genres")
    ax.set_xlabel(feature.replace('_',' ').title())
    ax.set_ylabel("Genre")
    return ax

def analyze_genre_explicitness(df: pd.DataFrame) -> Optional[pd.DataFrame]:
    """Calculates the percentage of explicit tracks per genre."""
    if not all(c in df.columns for c in ['artist_genres', 'explicit']):
        raise ValueError("Missing 'artist_genres' or 'explicit'.")
    
    exploded_df = _explode_genres(df)
    if exploded_df.empty: return None
    
    # Ensure explicit is numeric (0 or 1)
    exploded_df['explicit'] = exploded_df['explicit'].astype(float) 
    
    explicit_pct = exploded_df.groupby('genre')['explicit'].mean() * 100
    return explicit_pct.sort_values(ascending=False).reset_index(name='explicit_percentage')

def calculate_genre_diversity(df: pd.DataFrame, method: str = 'shannon') -> Optional[float]:
    """Calculates a diversity index (e.g., Shannon, Simpson) for saved genres."""
    exploded_df = _explode_genres(df)
    if exploded_df.empty: return None
    
    counts = exploded_df['genre'].value_counts()
    total = counts.sum()
    proportions = counts / total
    
    if method == 'shannon':
        # Shannon index: - sum(p_i * log(p_i))
        return -np.sum(proportions * np.log(proportions))
    elif method == 'simpson':
        # Simpson index: 1 - sum(p_i^2)
        return 1 - np.sum(proportions**2)
    else:
        raise ValueError("method must be 'shannon' or 'simpson'")

# --- Audio Feature Analysis ---

DEFAULT_AUDIO_FEATURES = [
    'danceability', 'energy', 'loudness', 'speechiness', 
    'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo'
]

def plot_audio_feature_distributions(df: pd.DataFrame, features: List[str] = DEFAULT_AUDIO_FEATURES) -> Optional[plt.Figure]:
    """Plots histograms/density plots for specified audio features."""
    
    actual_features = [f for f in features if f in df.columns]
    if not actual_features: raise ValueError("None of the specified features found in DataFrame.")
    
    plot_df = df[actual_features].copy()
    # Convert all to numeric, coercing errors
    for f in actual_features:
        plot_df[f] = pd.to_numeric(plot_df[f], errors='coerce')
    
    num_features = len(actual_features)
    # Adjust layout based on number of features
    ncols = 3 
    nrows = (num_features + ncols - 1) // ncols
    fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(ncols * 5, nrows * 4))
    axes = axes.flatten() # Flatten to easily iterate

    for i, feature in enumerate(actual_features):
        if plot_df[feature].notna().any(): # Only plot if data exists
             sns.histplot(plot_df[feature].dropna(), kde=True, ax=axes[i])
             axes[i].set_title(feature.replace('_',' ').title())
             axes[i].set_xlabel("") # Keep it cleaner

    # Hide unused subplots
    for j in range(i + 1, len(axes)):
        axes[j].set_visible(False)
        
    fig.suptitle("Distributions of Audio Features", fontsize=16, y=1.02)
    fig.tight_layout()
    return fig

def plot_audio_feature_correlations(df: pd.DataFrame, features: List[str] = DEFAULT_AUDIO_FEATURES, 
                                    method: str = 'pearson') -> Optional[plt.Axes]:
    """Plots a heatmap of correlations between specified audio features."""
    
    actual_features = [f for f in features if f in df.columns]
    if len(actual_features) < 2: 
        print("Need at least two features to calculate correlation.")
        return None

    # Convert to numeric before calculating correlation
    corr_df = df[actual_features].copy()
    for f in actual_features:
         corr_df[f] = pd.to_numeric(corr_df[f], errors='coerce')
         
    correlation_matrix = corr_df.corr(method=method)
    
    plt.figure(figsize=(10, 8))
    ax = sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
    ax.set_title(f"Correlation Matrix of Audio Features ({method.capitalize()})")
    return ax

def plot_feature_vs_popularity(df: pd.DataFrame, feature: str, kind: str = 'scatter') -> Optional[plt.Axes]:
    """Plots an audio feature vs. track popularity."""
    if feature not in df.columns: raise ValueError(f"Missing feature '{feature}'.")
    if 'popularity' not in df.columns: raise ValueError("Missing 'popularity'.")
    
    plot_df = df[[feature, 'popularity']].copy()
    plot_df[feature] = pd.to_numeric(plot_df[feature], errors='coerce')
    plot_df.dropna(inplace=True)
    if plot_df.empty: return None

    plt.figure(figsize=(10, 6))
    if kind == 'scatter':
        ax = sns.scatterplot(data=plot_df, x=feature, y='popularity', alpha=0.3)
    elif kind == 'hexbin':
        # Requires matplotlib hexbin - might need adjustments for sns style
        ax = plot_df.plot.hexbin(x=feature, y='popularity', gridsize=25, cmap='viridis', sharex=False) # sharex=False for matplotlib>=3.3 
    else:
        raise ValueError("kind must be 'scatter' or 'hexbin'")
        
    ax.set_title(f"Track Popularity vs. {feature.replace('_',' ').title()}")
    ax.set_xlabel(feature.replace('_',' ').title())
    ax.set_ylabel("Track Popularity")
    return ax

# --- Track Characteristics Analysis ---

def plot_duration_distribution(df: pd.DataFrame, time_unit: str = 'minutes') -> Optional[plt.Axes]:
    """Plots a histogram of track durations."""
    if 'duration_ms' not in df.columns: raise ValueError("Missing 'duration_ms'.")
    if df['duration_ms'].isnull().all(): return None

    plt.figure(figsize=(10, 6))
    if time_unit == 'minutes':
        durations = df['duration_ms'].dropna() / 60000
        xlabel = "Duration (minutes)"
    elif time_unit == 'seconds':
        durations = df['duration_ms'].dropna() / 1000
        xlabel = "Duration (seconds)"
    else: # milliseconds
        durations = df['duration_ms'].dropna()
        xlabel = "Duration (ms)"
        
    ax = sns.histplot(durations, kde=True)
    ax.set_title("Distribution of Track Durations")
    ax.set_xlabel(xlabel)
    return ax

def analyze_explicit_tracks_summary(df: pd.DataFrame, numeric_cols: List[str] = ['popularity', 'artist_popularity', 'energy', 'danceability', 'valence']) -> Optional[pd.DataFrame]:
    """Provides summary statistics comparing explicit vs. non-explicit tracks."""
    if 'explicit' not in df.columns: raise ValueError("Missing 'explicit'.")
    
    actual_cols = [col for col in numeric_cols if col in df.columns]
    if not actual_cols: return None # Return None if no numeric columns to analyze found

    # Ensure numeric types
    summary_df = df[['explicit'] + actual_cols].copy()
    for col in actual_cols:
         summary_df[col] = pd.to_numeric(summary_df[col], errors='coerce')

    summary = summary_df.groupby('explicit').agg(
        track_count=('explicit', 'size'),
        **{f'mean_{col}': (col, 'mean') for col in actual_cols}
    ).reset_index()
    return summary

# --- Advanced / Combined Analysis (Placeholders - Require more setup/libraries) ---

# def cluster_tracks_by_features(df: pd.DataFrame, features: List[str] = DEFAULT_AUDIO_FEATURES, n_clusters: int = 5) -> Optional[pd.Series]:
#     """Performs clustering (e.g., K-Means) on tracks based on audio features."""
#     # Implementation requires sklearn, scaling features, fitting KMeans, returning labels
#     pass

# def analyze_cluster_characteristics(df: pd.DataFrame, cluster_labels: pd.Series) -> Optional[pd.DataFrame]:
#     """Analyzes the characteristics (avg features, top genres) of each track cluster."""
#      # Implementation requires merging labels, grouping by cluster, aggregating
#     pass

# def plot_genre_network(df: pd.DataFrame, min_cooccurrence: int = 5):
#     """ Creates and potentially plots a network graph of genre co-occurrence."""
#     # Implementation requires networkx, calculating co-occurrence matrix, building graph
#     pass


# === Example Usage (in a separate script/notebook) ===
# import pandas as pd
# import spotify_analysis_library as sal # Assuming saved as spotify_analysis_library.py
# import matplotlib.pyplot as plt
#
# # Load the FINAL enriched data
# final_df = pd.read_parquet('path/to/saved_tracks_final_enriched.parquet')
#
# # --- Perform various analyses ---
#
# # Plot tracks added per year
# ax_added = sal.plot_tracks_added_distribution(final_df, period='Y')
# if ax_added: plt.show()
#
# # Plot release year distribution
# ax_release = sal.plot_release_year_distribution(final_df, bin_size=5) # 5-year bins
# if ax_release: plt.show()
#
# # Plot top genres
# ax_genres = sal.plot_genre_distribution(final_df, top_n=15)
# if ax_genres: plt.tight_layout(); plt.show()
#
# # Plot energy distribution by top genres
# ax_energy_genre = sal.plot_feature_by_genre(final_df, feature='energy', top_n_genres=10, plot_type='violin')
# if ax_energy_genre: plt.show()
#
# # Plot audio feature distributions
# fig_audio = sal.plot_audio_feature_distributions(final_df)
# if fig_audio: plt.show()
#
# # Plot audio feature correlations
# ax_corr = sal.plot_audio_feature_correlations(final_df)
# if ax_corr: plt.show()
#
# # Get top artists
# top_artists = sal.get_top_n_artists(final_df, n=10)
# print("Top 10 Artists (by track count):\n", top_artists)
#
# # Calculate genre diversity
# diversity = sal.calculate_genre_diversity(final_df, method='shannon')
# print(f"\nGenre Diversity (Shannon Index): {diversity:.3f}")